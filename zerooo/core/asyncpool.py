import asyncio
import os
import queue
import selectors
from threading import Thread

from zerooo.core.common import IS_WIN, IS_DARWIN
from zerooo.core.log import LOGGER


# 协程控制1.0
class AsyncPool:
    """
    1. 支持动态添加任务
    2. 支持自动停止事件循环
    3. 支持最大协程数
    """

    def __init__(self, limit=None):
        # 根据不同系统分配不同事件循环
        self.loop = self.get_event_loop()
        # 队列，先进先出，根据队列是否为空判断，退出协程
        self.task = queue.Queue()
        # 最大任务数
        self.maxsize = self.get_ulimit()
        # 协程池
        self.loops, _ = self.start_loop(self.loop)
        # 限制并发量
        if limit:
            self.semaphore = asyncio.Semaphore(int(limit), loop=self.loops)
        else:
            self.semaphore = asyncio.Semaphore(self.maxsize, loop=self.loops)

    def task_add(self, item=1):
        """
        添加任务
        :param item:
        :return:
        """
        self.task.put(item)

    def task_done(self, fn):
        """
        任务完成
        回调函数
        :param fn:
        :return:
        """
        if fn:
            pass
        self.task.get()
        self.task.task_done()

    def wait(self):
        """
        等待任务执行完毕
        :return:
        """
        self.task.join()

    @property
    def running(self):
        """
        获取当前线程数
        :return:
        """
        return self.task.qsize()

    @staticmethod
    def get_event_loop():
        # 设置对应系统事件循环
        if IS_WIN:
            loop = asyncio.ProactorEventLoop()
            asyncio.set_event_loop(loop)
            return loop
        else:
            # linux专用
            selector = selectors.DefaultSelector()
            # selector = selectors.SelectSelector()
            loop = asyncio.SelectorEventLoop(selector)
            asyncio.set_event_loop(loop)
            return loop

    @staticmethod
    def get_ulimit():
        global max_open_file
        if IS_WIN:
            max_open_file = 512 - 20
        elif IS_DARWIN:
            result = os.popen('launchctl limit maxfiles').read().split(' ')
            for i in result:
                if i.isdigit():
                    max_open_file = int(i) - 20
        else:
            max_open_file = int(os.popen('ulimit -n').read()) - 20

        return max_open_file

    @staticmethod
    def _start_thread_loop(loop):
        """
        运行事件循环
        :param loop: loop以参数的形式传递进来运行
        :return:
        """
        # 将当前上下文的事件循环设置为循环。
        asyncio.set_event_loop(loop)
        # 开始事件循环
        loop.run_forever()

    async def _stop_thread_loop(self, loop_time=1):
        """
        停止协程
        关闭线程
        :return:
        """
        while True:
            if self.task.empty():
                # 停止协程
                self.loop.stop()
                break
            await asyncio.sleep(loop_time)

    def start_loop(self, loop):
        """
        运行事件循环
        开启新线程
        :param loop: 协程
        :return:
        """
        # 获取一个事件循环
        if not loop:
            loop = asyncio.new_event_loop()

        loop_thread = Thread(target=self._start_thread_loop, args=(loop,))
        # 设置守护进程
        loop_thread.setDaemon(True)
        # 运行线程，同时协程事件循环也会运行
        loop_thread.start()

        return loop, loop_thread

    def stop_loop(self, loop_time=1):
        """
        队列为空，则关闭线程
        :param loop_time:
        :return:
        """
        # 关闭线程任务
        asyncio.run_coroutine_threadsafe(self._stop_thread_loop(loop_time), self.loop)

    def release(self, loop_time=1):
        """
        释放线程
        :param loop_time:
        :return:
        """
        self.stop_loop(loop_time)

    async def async_semaphore_func(self, func):
        """
        信号包装
        :param func:
        :return:
        """
        async with self.semaphore:
            return await func

    def submit(self, func, callback=None):
        """
        提交任务到事件循环
        :param func: 异步函数对象
        :param callback: 回调函数
        :return:
        """
        self.task_add()

        # 将协程注册一个到运行在线程中的循环，thread_loop 会获得一个环任务
        future = asyncio.run_coroutine_threadsafe(self.async_semaphore_func(func), self.loop)

        # 添加回调函数,添加顺序调用
        future.add_done_callback(callback)
        future.add_done_callback(self.task_done)


def async_run(func, items, callback, limit):
    """
    运行任务
    :param func: 异步函数对象
    :param items: 异步函数参数
    :param callback: 回调函数
    :return:
    """
    # 任务组， 最大协程数
    pool = AsyncPool(limit)

    # 插入任务任务
    # for i in range(100000):
    #     pool.submit(thread_example(i), my_callback)
    for i in items:
        pool.submit(func(i), callback)

    # 停止事件循环
    pool.release()

    # 获取线程数
    msg = f'Current task {pool.running}'
    LOGGER.info(msg)
    # 等待
    pool.wait()
