import subprocess
import sys
from glob import glob

from zerooo.core.common import IS_WIN
from zerooo.core.loader import load_module, del_module, reload_module, plugin_dict, load_plugins
from zerooo.core.log import LOGGER
from zerooo.core.options import optProxy, optDebug
from zerooo.core.settings import HELP, module_commands, BANNER, global_commands, module_path, global_plugins
from zerooo.utils.data import module_manager
from zerooo.utils.util import list_style, search_style

try:
    import readline
except ImportError:
    import pyreadline as readline


class BaseInterpreter(object):

    def __init__(self):
        if IS_WIN:
            self.raw_prompt = '{} > '
        else:
            self.raw_prompt = '\001\033[4m\002{}\001\033[0m\002 > '
        self.prompt_hostname = self.raw_prompt.format('zsf')
        self.current_module = None
        self.zsf_help = HELP
        return

    @staticmethod
    def completer(lists):
        def is_libedit():
            """判断是否开启补全"""
            try:
                return 'libedit' in readline.__doc__
            except TypeError:
                return False

        # source: https://gist.github.com/iamatypeofwalrus/5637895
        class tabCompleter(object):
            def __init__(self):
                self.listCompleter = None

            def pathCompleter(self, text, state):
                line = readline.get_line_buffer().split()
                return [x for x in glob(text + '*')][state]

            def createListCompleter(self, ll):
                def listCompleter(text, state):
                    line = readline.get_line_buffer()
                    if not line:
                        return None
                    else:
                        return [c + ' ' for c in ll if c.startswith(line)][state]

                self.listCompleter = listCompleter

        t = tabCompleter()
        # tool command
        t.createListCompleter(lists)
        # print(lists)
        readline.set_completer_delims('\t')
        # readline.parse_and_bind("tab: complete")
        if is_libedit():
            readline.parse_and_bind('bind ^I rl_complete')
        else:
            readline.parse_and_bind('tab: complete')
        readline.set_completer(t.listCompleter)

    # @staticmethod
    # def is_libedit():
    #     """判断是否开启补全"""
    #     try:
    #         return 'libedit' in readline.__doc__
    #     except TypeError:
    #         return False

    # @staticmethod
    # def complete(history_values):
    #     def custom_complete(text, state):
    #         if state == 0:
    #             return []
    #         results = [h for h in history_values if h.startswith(text)] + [None]
    #         # for i in history_values:
    #         #     if i.startswith(text):
    #         #         print('aaaa:', i)
    #         #         # print(i[state])
    #         #     else:
    #         #         print('bbbb:', i)
    #         # results = [h for h in history_values if h.startswith(text)]
    #         # print(state,str(results[state]))
    #         # if len(results[state]) > 1:
    #         # print(results[state])
    #         return str(results[state]) + ' '
    #         # else:
    #         #     return None
    #         # if results[state]:
    #
    #     return custom_complete

    # def setup(self, history_values):
    #
    #     if self.is_libedit():
    #         readline.parse_and_bind('bind ^I rl_complete')
    #     else:
    #         readline.parse_and_bind('tab: complete')
    #
    #     readline.set_completer(None)
    #
    #     readline.set_completer(self.complete(history_values))

    @staticmethod
    def parse_line(line):
        """
        分割用户输入
        :param line: input
        :return: (command, arg)
        """
        command, _, arg = line.strip().partition(' ')  # 例如：use exploit/struts2/s2-057
        return command, arg  # 例如： command = set, arg = exploit/struts2/s2-057

    # @staticmethod
    def current_status(self, arg):
        """获取当前状态"""
        prompt_str = arg.split('/')
        prompt = self.prompt_hostname.replace('>', f'({prompt_str[-1]}) >')
        return prompt

    def module_use(self, module_path):
        """选择模块"""
        self.current_module = load_module(module_path)
        # self.setup(module_commands)
        return self.current_module

    def module_del(self):
        """删除模块"""
        del_module(self.current_module)

    @staticmethod
    def parse_plugin(plugin):
        """解析插件"""
        if plugin in global_plugins:
            return plugin
        else:
            return None


class Interpreter(BaseInterpreter):
    def __init__(self):
        super().__init__()
        self.banner = BANNER
        self.global_commands = global_commands
        self.module_commands = module_commands
        # 插件对象
        self.clazz = plugin_dict
        # self.module_path = []
        for i in module_path: self.global_commands.extend(list(i))
        # self.setup(self.global_commands)
        # self.commands = {'?': self.command_help, 'help': self.command_help, 'use': self.module_use, 'exit': sys.exit, 'quit': sys.exit}
        # self.module_commands = {'exit': self.command_back, 'exploit': self.command_run, 'info': self.command_show_info, 'options': self.command_show_options, 'run': self.command_run, 'set': self.command_set, 'reload': self.command_reload}

    def module_metadata(self):
        module = getattr(self.current_module, 'info')
        return module['Module']

    @property
    # 控制input状态
    def prompt(self):
        if self.current_module:
            module_opts = []
            module_opts.extend(self.module_commands)
            module_opts.extend(self.get_opts())
            self.completer(module_opts)
            return self.current_status(self.module_metadata())

        else:
            # print(self.global_commands)
            # self.setup(self.global_commands)
            self.completer(self.global_commands)
            # self.setup(self.module_path)
            return self.prompt_hostname

    def command_handle(self, command, args):
        if self.current_module:
            if command == 'run' or command == 'exploit':
                self.command_run()
            elif command == 'back' or command == 'exit':
                self.command_back()
            elif command == 'set' and args:
                self.command_set(args)
            elif command == 'show' and args == 'options':
                self.command_show_options()
            elif command == 'show' and args == 'info':
                self.command_show_info()
            elif command == 'reload':
                self.command_reload()
            else:
                LOGGER.error('未知命令 (Unknow command) : {0}.'.format(command, args))
        else:
            if command == 'use':
                self.module_use(args)
            elif self.parse_plugin(command):
                self.command_load_plugin(command)
            elif command == 'help' or command == '?':
                self.command_help()
            elif command == 'setg' and args:
                self.command_setg(args)
            elif command == 'unsetg' and args:
                self.command_unsetg(args)
            elif command == 'exit' or command == 'quit':
                sys.exit()
            elif command == 'exec' and args:
                self.command_exec(args)
            elif command == 'search' and args:
                self.command_search(args)
            elif command == 'list':
                self.command_modules_list()
            elif command == 'show':
                self.command_show()
            else:
                LOGGER.error('未知命令 (Unknow command) : {0}.'.format(command + args))

    @staticmethod
    def command_show():
        print('proxy:', optProxy.__get__())
        print('debug:', optDebug.__get__())

    def command_help(self):
        print(self.zsf_help)

    def command_show_info(self):
        self.current_module.show_info()

    def command_show_options(self):
        self.current_module.show_options(self.module_metadata())

    def command_set(self, args):
        if len(args.split(' ')) == 2:
            key = args.split(' ')[0]
            value = args.split(' ')[1]
            self.current_module.register_option(key, value)
        else:
            key = args.split(' ')[0]
            value = args.replace(key, '')
            new_value = value[:0] + value[0 + 1:]
            self.current_module.register_option(key, new_value)

    @staticmethod
    def command_setg(args):
        if len(args.split(' ')) == 2:
            parse = args.split(' ')
            if parse[0] == 'proxy':
                optProxy.__set__(parse[1])
            elif parse[0] == 'debug':
                optDebug.__set__(parse[1])

    @staticmethod
    def command_unsetg(args):
        if len(args.split(' ')) == 2:
            parse = args.split(' ')
            if parse[0] == 'proxy':
                optProxy.__set__(None)
        else:
            LOGGER.warning('请输入unsetg关键字 (Please input unsetg keyword): <proxy>')

    @staticmethod
    def command_search(args):
        if len(args.split(' ')) == 1:
            keyword = args.split(' ')[0]
            result = module_manager.search_module(keyword)
            if not result:
                msg = f'未找到 (Not find) : {keyword}'
                LOGGER.info(msg)
            else:
                search_style(result)
        else:
            LOGGER.warning('请输入search 关键字 (Please input search): <keyword>')

    def command_back(self):
        self.module_del()
        self.current_module = None

    def check_run(self):
        # 运行前检查必填参数
        options = self.current_module.option
        for k, v in options.items():
            c_set = v['Current Setting']
            required = v['Required']
            if not c_set and required == 'yes':
                LOGGER.warning(f'未设置 (Not set) : {k}')
                return False

        return True

    def command_run(self):
        LOGGER.info(f'运行模块 (Running module) : {self.module_metadata()}...')
        if self.check_run():
            self.current_module.exploit()

    def command_reload(self):
        module_metadata = self.module_metadata()
        LOGGER.info(f'重新载入模块 (Reloading module): {module_metadata}...')
        reload_module()
        self.command_back()
        LOGGER.success(f'重载完成, 请重新输入 (Reload complete, please use): {module_metadata}')

    @staticmethod
    def command_exec(args):
        # 执行系统命令并时时打印
        msg = f'调用命令 (exec command): {args}'
        LOGGER.info(msg)
        process = subprocess.Popen(args, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        while process.poll() is None:
            line = process.stdout.readline()
            line = line.strip()
            if line:
                if IS_WIN:
                    print(line.decode('gbk', 'ignore'))
                else:
                    print(line.decode('utf-8', 'ignore'))

    @staticmethod
    def command_modules_list():
        exps = module_manager.module_list('Exploit')
        auxs = module_manager.module_list('Auxiliary')
        exps.extend(auxs)
        list_style(exps)

    def command_load_plugin(self, plugin):
        return self.clazz[plugin].run()

    def get_opts(self):
        # 获取模块参数
        l = []
        options = self.current_module.option
        for k, v in options.items():
            l.append('set ' + k)

        return l

    def start(self):
        """用户输入输出循环"""
        print(self.banner)
        load_plugins()
        while True:
            try:
                command, args = self.parse_line(input(self.prompt))
                if not command:
                    continue

                self.command_handle(command, args)

            except (KeyboardInterrupt, EOFError):
                LOGGER.info('中止: 使用 \'exit\' 命令退出 (Interrupt: use the \'exit\' command to quit)')
                # 清理协程
                # if self.current_module:
                #     pass
