#!/usr/bin/python
# -*- coding:utf8 -*-
"""
Io Handler classes

提供输入输出工作
"""

import os
try:
    import readline
except ImportError:
    import pyreadline as readline

from zerooosploit.exception import ZeroooException
from zerooosploit.exploits import ExploitAggregate
from zerooosploit.color import *
from zerooosploit import proxy


# 命令补全文件
COMPLETION_FILE = '.zerooo.conf'


def is_libedit():
    """判断是否开启补全，返回True或False"""
    try:
        return 'libedit' in readline.__doc__
    except TypeError:
        return False


def get_history_items():
    """迭代命令"""
    return [readline.get_history_item(i)
            for i in range(1, readline.get_current_history_length() + 1)
            ]


class BaseInterpreter(object):

    def __init__(self):
        self.banner = '''
                                                 _       _ _ 0.0.1#dev
 _______ _ __ ___   ___   ___  ___ _ __ | | ___ (_) |_
|_  / _ \ r'__/ _ \ / _ \ / _ \/ __| '_ \| |/ _ \| | __|
 / /  __/ | | (_) | (_) | (_) \__ \ |_) | | (_) | | |_
/___\___|_|  \___/ \___/ \___/|___/ .__/|_|\___/|_|\__|
                                  |_|
        
        Zerooo Exploitation Framework
        
        Exploits: {0}
        
        
        '''.format(4)
        self.prompt = 'zsf > '
        self.zsf_help = '''\n
Core Commands
=============

    Command       Description
    -------       -----------
    ?             Help menu
    help          Help menu
    use           Selects a module name
    show          Displays modules of a given type
    exit          Exit the console


Module Commands
===============

    Command       Description
    -------       -----------
    set           Set a text to a value
    options       Displays modules options
    info          Displays modules information
    exploit       Attack targets
    run           Attack targets
    
'''
        self.matches = []
        self.setup()
        return

    def complete(self, text, state):
        response = None
        if state == 0:
            history_values = get_history_items()
            if text:
                self.matches = sorted(
                    h for h in history_values if h and h.startswith(text))
            else:
                self.matches = []
        try:
            response = self.matches[state]
        except IndexError:
            pass
        return response

    def setup(self):
        if os.path.exists(COMPLETION_FILE):
            readline.read_history_file(COMPLETION_FILE)

        readline.set_completer(self.complete)
        if is_libedit():
            readline.parse_and_bind("bind ^I rl_complete")
        else:
            readline.parse_and_bind("tab: complete")

    @staticmethod
    def parse_line(line):
        """
        分割用户输入
        :param line: input
        :return: (command, arg)
        """
        command, _, arg = line.strip().partition(' ')  # 例如：use exploits/struts2/s2-057
        return command, arg  # 例如： command = set, arg = exploits/struts2/s2-057

    @staticmethod
    def current_status(arg):
        """获取当前状态"""
        prompt_str = arg.split('/')  # ['exploits', 'struts2', 's2-057']
        return 'zsf ({}) > '.format(prompt_str[-1])

    @staticmethod
    def show_modules():
        """列出所有模块"""
        file_count = 0
        exp = []
        for dirpath, dirnames, filenames in os.walk('./modules/exploits'):
            for file in filenames:
                file_count = file_count + 1
                if '__init__' in file:
                    pass
                elif '.pyc' in file:
                    pass
                else:
                    exp.append(file)

        for i in exp:
            print(i)

    def command_help(self):
        print(self.zsf_help)


class Interpreter(BaseInterpreter):
    def __init__(self):
        super().__init__()
        self.current_module = None

    def module_use(self, module_path):
        """选择模块"""
        module_path = module_path.replace('/', '.')
        self.current_module = ExploitAggregate.select_modules(modules=module_path)
        return self.current_module

    def module_del(self):
        ExploitAggregate.del_modules(self.current_module)

    def start(self):
        """用户输入输出循环"""
        print_yellow(self.banner)
        while True:
            try:
                command, args = self.parse_line(input(self.prompt).lower())
                if not command:
                    continue

                elif command == 'use':
                    try:
                        self.module_use(args)
                    except ModuleNotFoundError as err:
                        print_red('[-] {}'.format(err))
                        continue
                # elif command.startswith('proxy'):
                #     if len(args.split(':')) == 4:
                #         proxy_type = args.split(':')[0]
                #         proxy_ip = args.split(':')[1]
                #         proxy_port = args.split(':')[2]
                #         proxy_status = args.split(':')[3]
                #         proxy.proxy_set(proxy_type, proxy_ip, proxy_port, proxy_status)
                #
                #     continue
                elif command == 'exit':
                    exit()
                else:
                    continue
                while True:
                    command = input(self.current_status(args)).lower()
                    if command == 'show info':
                        self.current_module.show_info()
                    elif command == 'show options':
                        self.current_module.show_options()
                    elif command.startswith('set '):
                        if len(command.split(' ')) == 3:
                            key = command.split(' ')[1]
                            value = command.split(' ')[2]
                            self.current_module.register_option(key, value)
                    elif command == 'exploit' or command == 'run':
                        self.current_module.exploit()
                    elif command == 'exit':
                        self.module_del()
                        break
            except (KeyboardInterrupt, SystemExit, EOFError):
                break
