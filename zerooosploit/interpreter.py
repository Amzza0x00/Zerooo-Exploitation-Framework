#!/usr/bin/python
# -*- coding:utf8 -*-
"""
input classes

提供输入输出工作
"""

import os
import sys
try:
    import readline
except ImportError:
    import pyreadline as readline

# from zerooosploit.exception import ZeroooException
from zerooosploit.exploits import ExploitAggregate
from zerooosploit.color import *


# 命令补全文件
COMPLETION_FILE = '.zerooo.conf'


def is_libedit():
    """判断是否开启补全"""
    try:
        return 'libedit' in readline.__doc__
    except TypeError:
        return False


def get_history_items():
    """迭代命令"""
    return [
        readline.get_history_item(i)
            for i in range(1, readline.get_current_history_length() + 1)
            ]


class BaseInterpreter(object):

    def __init__(self):
        self.prompt_hostname = 'zsf > '
        self.current_module = None
        self.zsf_help = '''\n
Core Commands
=============

    Command       Description
    -------       -----------
    ?             Help menu
    exit          Exit the console
    help          Help menu
    quit          Exit the console
    use           Selects a module name


Module Commands
===============

    Command       Description
    -------       -----------
    exit          Unload current module
    exploit       Attack targets
    info          Displays modules information
    options       Displays modules options
    run           Attack targets
    show          Displays modules of a given type 
    set           Set a text to a value
    
'''
        self.matches = []
        self.setup()
        return

    def complete(self, text, state):
        response = None
        if state == 0:
            history_values = get_history_items()
            if text:
                self.matches = sorted(
                    h for h in history_values if h and h.startswith(text))
            else:
                self.matches = []
        try:
            response = self.matches[state]
        except IndexError:
            pass

        return response

    def setup(self):
        if os.path.exists(COMPLETION_FILE):
            readline.read_history_file(COMPLETION_FILE)

        readline.set_completer(self.complete)
        if is_libedit():
            readline.parse_and_bind('bind ^I rl_complete')
        else:
            readline.parse_and_bind('tab: complete')

    @staticmethod
    def parse_line(line):
        """
        分割用户输入
        :param line: input
        :return: (command, arg)
        """
        command, _, arg = line.strip().partition(' ')  # 例如：use exploits/struts2/s2-057
        return command, arg  # 例如： command = set, arg = exploits/struts2/s2-057

    @staticmethod
    def current_status(arg):
        """获取当前状态"""
        prompt_str = arg.split('/')  # ['exploits', 'struts2', 's2-057']
        return 'zsf ({}) > '.format(prompt_str[-1])

    @staticmethod
    def show_modules():
        """列出所有模块"""
        file_count = 0
        exp = []
        for dirpath, dirnames, filenames in os.walk('./modules/exploits'):
            for file in filenames:
                file_count = file_count + 1
                if '__init__' in file:
                    pass
                elif '.pyc' in file:
                    pass
                else:
                    if '.py' in file:
                        exp.append(file)
                    else:
                        pass

        return exp

    def command_help(self):
        print(self.zsf_help)

    def module_use(self, module_path):
        """选择模块"""
        module_path = module_path.replace('/', '.')
        self.current_module = ExploitAggregate.select_modules(modules=module_path)
        return self.current_module

    def module_del(self):
        """删除模块"""
        ExploitAggregate.del_modules(self.current_module)


class Interpreter(BaseInterpreter):
    def __init__(self):
        super().__init__()
        self.banner = '''
                                                 _       _ _ 0.0.1#dev
 _______ _ __ ___   ___   ___  ___ _ __ | | ___ (_) |_
|_  / _ \ r'__/ _ \ / _ \ / _ \/ __| '_ \| |/ _ \| | __|
 / /  __/ | | (_) | (_) | (_) \__ \ |_) | | (_) | | |_
/___\___|_|  \___/ \___/ \___/|___/ .__/|_|\___/|_|\__|
                                  |_|

        Zerooo Exploitation Framework

        Exploits: {0}


        '''.format(len(self.show_modules()))
        self.commands = {'?': self.command_help, 'help': self.command_help, 'use': self.module_use, 'exit': sys.exit, 'quit': sys.exit}
        self.module_commands = {'exit': self.command_back, 'exploit': self.command_run, 'info': self.command_show_info, 'options': self.command_show_options, 'run': self.command_run, 'set': self.command_set}

    def module_metadata(self):
        module = getattr(self.current_module, 'info')
        return module['Module']

    @property
    def prompt(self):
        if self.current_module:
            return self.current_status(self.module_metadata())

        else:
            return self.prompt_hostname

    def command_handle(self, command, args):
        if self.current_module:
            try:
                self.module_commands[command](args)
            except TypeError:
                self.module_commands[command]()
            except KeyError:
                if command == 'show' and args in self.module_commands:
                    self.module_commands[args]()
                elif command == 'set' and args:
                    self.module_commands[command](args)
                else:
                    print_red('[-] Unknow command: {0}.'.format(command))
        else:
            try:
                self.commands[command](args)
            except TypeError:
                self.commands[command]()
            except KeyError:
                print_red('[-] Unknow command: {0}.'.format(command))

    def command_show_info(self):
        self.current_module.show_info()

    def command_show_options(self):
        self.current_module.show_options(self.module_metadata())

    def command_set(self, args):
        if len(args.split(' ')) == 2:
            key = args.split(' ')[0]
            value = args.split(' ')[1]
            self.current_module.register_option(key, value)

    def command_back(self):
        self.module_del()
        self.current_module = None

    def command_run(self):
        print('Running module {0}...'.format(self.module_metadata()))
        self.current_module.exploit()

    def start(self):
        """用户输入输出循环"""
        print_yellow(self.banner)
        while True:
            try:
                command, args = self.parse_line(input(self.prompt).lower())
                if not command:
                    continue

                self.command_handle(command, args)

            except (KeyboardInterrupt, EOFError):
                print('Interrupt: use the \'exit\' command to quit')
