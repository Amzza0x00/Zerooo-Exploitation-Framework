#!/usr/bin/python
# -*- coding:utf8 -*-
"""
Io Handler classes

提供输入输出工作
"""

import os
try:
    import readline
except ImportError:
    import pyreadline as readline

from zerooosploit import color
from zerooosploit import exception
from zerooosploit import exploits


# 命令补全文件
COMPLETION_FILE = '.zeroocmd.conf'


def is_libedit():
    """判断是否开启补全，返回True或False"""
    try:
        return 'libedit' in readline.__doc__
    except TypeError:
        return False


def get_history_items():
    """迭代命令"""
    return [readline.get_history_item(i)
            for i in range(1, readline.get_current_history_length() + 1)
            ]


class Iohandler:

    def __init__(self):
        self.banner = '''
                                                 _       _ _ 0.0.1#dev
 _______ _ __ ___   ___   ___  ___ _ __ | | ___ (_) |_
|_  / _ \ r'__/ _ \ / _ \ / _ \/ __| '_ \| |/ _ \| | __|
 / /  __/ | | (_) | (_) | (_) \__ \ |_) | | (_) | | |_
/___\___|_|  \___/ \___/ \___/|___/ .__/|_|\___/|_|\__|
                                  |_|
        
        Zerooo Exploitation Framework
        
        Exploits: 4
        
        
        '''
        self.prompt = 'zsf > '
        self.matches = []
        self.setup()
        return

    def complete(self, text, state):
        response = None
        if state == 0:
            history_values = get_history_items()
            if text:
                self.matches = sorted(
                    h for h in history_values if h and h.startswith(text))
            else:
                self.matches = []
        try:
            response = self.matches[state]
        except IndexError:
            pass
        return response

    def setup(self):
        if os.path.exists(COMPLETION_FILE):
            readline.read_history_file(COMPLETION_FILE)

        readline.set_completer(self.complete)
        if is_libedit():
            readline.parse_and_bind("bind ^I rl_complete")
        else:
            readline.parse_and_bind("tab: complete")

    @staticmethod
    def parse_line(line):
        """
        分割用户输入
        :param line: input
        :return: (command, arg)
        """
        cmd, _, arg = line.strip().partition(' ')  # 例如：use exploits/struts2/s2-057
        return cmd, arg  # 例如： command = set, arg = exploits/struts2/s2-057

    @staticmethod
    def current_status(arg):
        """获取当前状态"""
        prompt_str = arg.split('/')  # ['exploits', 'struts2', 's2-057']
        return 'zsf ({}) > '.format(prompt_str[-1])

    @staticmethod
    def show_modules():
        """列出所有模块"""
        file_count = 0
        exp = []
        for dirpath, dirnames, filenames in os.walk('./modules/exploits'):
            for file in filenames:
                file_count = file_count + 1
                if '__init__' in file:
                    pass
                elif '.pyc' in file:
                    pass
                else:
                    exp.append(file)

        for i in exp:
            print(i)

    def start(self):
        """用户输入输出循环"""
        print(color.output_yellow(self.banner))
        while True:
            try:
                cmd, args = self.parse_line(input(self.prompt).lower())
                module_name = args.replace('/', '.')
                if not cmd:
                    continue
                elif cmd == 'exit':
                    exit()
                elif cmd == 'show' and args == 'modules':
                    self.show_modules()
                elif cmd == 'use':
                    try:
                        module = exploits.ExploitAggregate().select_modules(modules=module_name)
                        exploit = module.Exploit()
                    except Exception:
                        try:
                            raise exception.ModuleNotFoundError(module_name)
                        except exception.ModuleNotFoundError as e:
                            print(e)
                            continue
                    while True:
                        command = input(self.current_status(args)).lower()
                        if command == 'run' or command == 'exploit':
                            exploits.ExploitAggregate().exploit(modules=module_name)
                        elif command == 'exit':
                            exploits.ExploitAggregate().del_modules(modules=module_name)
                            break
                        elif command == 'show options':
                            exploit.show_options()
                        elif command == 'show info':
                            exploit.show_info()
                        elif command.startswith('set '):
                            if len(command.split(' ')) == 3:
                                key = command.split(' ')[1]
                                value = command.split(' ')[2]
                                exploit.register_option(key, value)
                        else:
                            try:
                                raise exception.CommandException(command)
                            except exception.CommandException as e:
                                print(e)
            except (KeyboardInterrupt, SystemExit):
                pass
